객체 지향 언어2 
---
5번째 수업
---

### instanceof 연산자
* 레퍼런스객체 instanceof 클래스명 (반환값 : true / false)
* **레퍼런스**가 가리키는 객체가 해당  **클래스** 타입의 객체인지 판단하는 연산자

---
### 메소드 오버라이딩
* 메소드 이름이 같다.(이 조건만 성립한다면 오버로딩과 다를게 없다.)
* 상속관계에서 부모 클래스의 메소드와 자식 클래스의 메소드 이름이 같을 수 있는 것을 말한다.
* 오버로딩과 다르게 매개변수의 타입, 갯수 리턴타입은 상관이 없다.
* 슈퍼 클래스의 메소드와 **동일한 원형**으로 작성해야한다.
* 슈퍼 클래스 메소드의 접근 지정자보다 **접근 범위를 좁여** 오버라이딩 할 수 없다.
* **static**이나 **private** 또는 **final**로 선언된 메소드는 서브 클래스에서 오버라이딩할 수 없다.

---
### 추상 클래스 (코드의 해석, 이해)
* 추상 메소드가 하나라도 있는 클래스
* 추상 메소드가 뭔데?  
  - 선언은 되어 있으나 구현되어 있지 않은 메소드, abstract 키워드로 선언.  
  ```
  public abstract String getName();
  ```
* 추상 메소드는 서브 클래스에서 오버라이딩하여 구현해야 됨.
* 추상 클래스의 특징  
  - 추상클래스에서 레퍼런스 변수는 선언가능
  - 추상클래스는 객체 생성 불가 new Shape()
* 추상클래스를 상속받고 서브클래스가 슈퍼클래스의 추상메소도를 오버라이딩 하지 않는다면, 
  상속받은 서브클래스에게 **abstract**키워드를 통해 추상클래스임을 명시해야한다.
* 추상클래스의 구현 목적
  - 추상 클래스는 추상 메소드를 통해 서브클래스가 구현할 메소드를 명료하게 알려주는 **인터페이스**의 역할을 하고,
    서브클래스는 추상 메소드를 목적에 맞게 구현하는 **다형성**을 실현할 수 있다.

---
### 인터페이스
* 클래스가 구현해야 할 메소드들이 선언되는 추상형(abstract)
* 인터페이스 선언
  - interface 키워드로 선언한다.
  ```
  public interface SerialDriver {...}
  ```
* java 7
  - 인터페이스는 상수와 추상 메소드로만 구성
* java 7 이상
  - 상수와 추상메소드포함(java7)
  - default 메소드 포함(java8)
  - private 메소드 포함(java9)
  - static메소드 포함(java9)
  - 여전히 인터페이스에서는 필드 (멤버 변수) **선언 불가** 
* 인터페이스는 객체를 생성할 수 없다.
* 인터페이스 타입의 레퍼런스 변수는 선언이 가능하다.
* 인터페이스끼리 상속이 가능하다.
* 인터페이스 클래스는 **implements** 키워드로 상속받을 수 있다.
* class에서 인터페이스를 상속받을 경우
  - implements 키워드를 사용하여 상속받는다 
```
class SamsungPhone implements PhoneInterface {...}
```
* 인터페이스에서 인터페이스를 상속받을 경우
  - extends 키워드를 사용하여 상속받는다 
```
interface MobilePhoneInterface extends PhoneInterface {...}
```
* 인터페이스는 다중 상속을 허용한다.
```
interface MusicPhoneInterface extends MobilePhoneInterface, Mp3Interface {...}
```
* 인터페이스를 사용하는 이유가 뭔데?
  - 자바에서는 클래스의 다중 상속을 **허용하지 않는다**.
  - 이러한 제한으로 인해 다중 상속같은? 효과를 보기 위해서 interface를 구현하여 interface를 **다중 상속**받고 여러 메소드를 오버라이딩하고 클래스에 implements로 상속받아 **자바의 단일 상속의 한계를 극복**할 수 있다.
  
    

    

